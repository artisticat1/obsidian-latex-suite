// Conceal functions

import { EditorView } from "@codemirror/view";
import { getMathBoundsPlugin } from "src/utils/context";
import { findMatchingBracket } from "src/utils/editor_utils";
import { ConcealSpec, mkConcealSpec } from "./conceal";
import { greek, cmd_symbols, map_super, map_sub, fractions, brackets, mathscrcal, mathbb, operators, not_remap as raw_not_remap } from "./conceal_maps";



/**
 *sort by length. This is a workaround for ios devices < 16.4 where lookbehind is not supported.
 * This is to ensure regex preferes "top" over "to" for the string "\\top" since top is earlier as on of the options in the regex.
 */
const ALL_SYMBOLS: Record<string,string> = Object.fromEntries(
	Object.entries({...greek, ...cmd_symbols}).sort((a,b) => b[0].length - a[0].length)
)
const not_remap: Record<string,string> = Object.fromEntries([
	...Object.entries(raw_not_remap).sort((a,b) => b[0].length - a[0].length)
]);

export function escapeRegex(regex: string) {
	const escapeChars = ["\\", "(", ")", "+", "-", "[", "]", "{", "}", "."];

	for (const escapeChar of escapeChars) {
		regex = regex.replaceAll(escapeChar, "\\" + escapeChar);
	}

	return regex;
}

/**
 * gets the updated end index to include "\\limits" in the concealed text of some conceal match,
 * if said match is directly followed by "\\limits"
 *
 * @param eqn source text
 * @param end index of eqn corresponding to the end of a match to conceal
 * @returns the updated end index to conceal
 */
function getEndIncludingLimits(eqn: string, end: number): number {
	const LIMITS = "\\limits";
	if (eqn.substring(end, end + LIMITS.length) === LIMITS) {
		return end + LIMITS.length;
	}
	return end;
}
/**
 * Conceals all symbols and ensures \not gets priority over the normal symbol.
 * @param eqn the equation that need to be concealed
 * @param symbols normal symbols with \ as prefix
 * @param notSymbols symbols that can be negated with \not before
 * @returns the concealed text
 */
function concealNotSymbols(eqn: string, symbols: Record<string,string>, notSymbols: Record<string,string>): ConcealSpec[] {
	const normalSpec = concealSymbols(eqn, "\\\\", "", symbols, undefined, false);
	const notSpec = concealSymbols(eqn, "\\\\not[ \t]*\\\\", "", notSymbols, undefined, false);
	const spec: ConcealSpec[] = [];
	const notSpecEnds: number[] = []
	for (let i = 0; i < notSpec.length; i++){
		spec.push(notSpec[i]);
		notSpecEnds.push(normalSpec[i][0].end);
	}
	for (let i = 0; i < normalSpec.length; i++){
		if (!notSpecEnds.includes(normalSpec[i][0].end)){
			spec.push(normalSpec[i]);
		}
	}
	return spec;
}

function concealSymbols(eqn: string, prefix: string, suffix: string, symbolMap: {[key: string]: string}, className?: string, allowSucceedingLetters = true): ConcealSpec[] {
	const symbolNames = Object.keys(symbolMap);

	const regexStr = prefix + "(" + escapeRegex(symbolNames.join("|")) + ")" + suffix;
	const symbolRegex = new RegExp(regexStr, "g");


	const matches = [...eqn.matchAll(symbolRegex)];

	const specs: ConcealSpec[] = [];

	for (const match of matches) {
		const symbol = match[1];

		if (!allowSucceedingLetters) {
			// If the symbol match is succeeded by a letter (e.g. "pm" in "pmatrix" is succeeded by "a"), don't conceal

			const end = match.index + match[0].length;
			if (eqn.charAt(end).match(/[a-zA-Z]/)) {
				continue;
			}
		}

		const end = getEndIncludingLimits(eqn, match.index + match[0].length);

		specs.push(mkConcealSpec({
			start: match.index,
			end: end,
			text: symbolMap[symbol],
			class: className,
		}));
	}

	return specs;
}

function concealModifier(eqn: string, modifier: string, combiningCharacter: string): ConcealSpec[] {

	const regexStr = ("\\\\" + modifier + "{([A-Za-z])}");
	const symbolRegex = new RegExp(regexStr, "g");


	const matches = [...eqn.matchAll(symbolRegex)];

	const specs: ConcealSpec[] = [];

	for (const match of matches) {
		const symbol = match[1];

		specs.push(mkConcealSpec({
			start: match.index,
			end: match.index + match[0].length,
			text: symbol + combiningCharacter,
			class: "latex-suite-unicode",
		}));
	}

	return specs;
}

function concealSupSub(eqn: string, superscript: boolean, symbolMap: {[key: string]:string}): ConcealSpec[] {

	const prefix = superscript ? "\\^" : "_";
	const regexStr = prefix + "{([A-Za-z0-9\\()\\[\\]/+-=<>':;\\\\ *]+)}";
	const regex = new RegExp(regexStr, "g");

	const matches = [...eqn.matchAll(regex)];


	const specs: ConcealSpec[] = [];

	for (const match of matches) {

		const exponent = match[1];
		const elementType = superscript ? "sup" : "sub";


		// Conceal super/subscript symbols as well
		const symbolNames = Object.keys(symbolMap);

		const symbolRegexStr = "\\\\(" + escapeRegex(symbolNames.join("|")) + ")";
		const symbolRegex = new RegExp(symbolRegexStr, "g");

		const replacement = exponent.replace(symbolRegex, (a, b) => {
			return symbolMap[b];
		});


		specs.push(mkConcealSpec({
			start: match.index,
			end: match.index + match[0].length,
			text: replacement,
			class: "cm-number",
			elementType: elementType,
		}));
	}

	return specs;
}

function concealModified_A_to_Z_0_to_9(eqn: string, mathBBsymbolMap: {[key: string]:string}): ConcealSpec[] {

	const regexStr = "\\\\(mathbf|boldsymbol|underline|mathrm|text|mathbb){([A-Za-z0-9 ]+)}";
	const regex = new RegExp(regexStr, "g");

	const matches = [...eqn.matchAll(regex)];

	const specs: ConcealSpec[] = [];

	for (const match of matches) {
		const type = match[1];
		const value = match[2];

		const start = match.index;
		const end = start + match[0].length;

		if (type === "mathbf" || type === "boldsymbol") {
			specs.push(mkConcealSpec({
				start: start,
				end: end,
				text: value,
				class: "cm-concealed-bold",
			}));
		}
		else if (type === "underline") {
			specs.push(mkConcealSpec({
				start: start,
				end: end,
				text: value,
				class: "cm-concealed-underline",
			}));
		}
		else if (type === "mathrm") {
			specs.push(mkConcealSpec({
				start: start,
				end: end,
				text: value,
				class: "cm-concealed-mathrm",
			}));
		}
		else if (type === "text") {
			// Conceal _\text{}
			if (start > 0 && eqn.charAt(start - 1) === "_") {
				specs.push(mkConcealSpec({
					start: start - 1,
					end: end,
					text: value,
					class: "cm-concealed-mathrm",
					elementType: "sub",
				}));
			}
		}
		else if (type === "mathbb") {
			const letters = Array.from(value);
			const replacement = letters.map(el => mathBBsymbolMap[el]).join("");
			specs.push(mkConcealSpec({start: start, end: end, text: replacement}));
		}

	}

	return specs;
}

function concealModifiedGreekLetters(eqn: string, greekSymbolMap: {[key: string]:string}): ConcealSpec[] {

	const greekSymbolNames = Object.keys(greekSymbolMap);
	const regexStr = "\\\\(underline|boldsymbol){\\\\(" + escapeRegex(greekSymbolNames.join("|"))  + ")}";
	const regex = new RegExp(regexStr, "g");

	const matches = [...eqn.matchAll(regex)];

	const specs: ConcealSpec[] = [];

	for (const match of matches) {
		const type = match[1];
		const value = match[2];

		const start = match.index;
		const end = start + match[0].length;

		if (type === "underline") {
			specs.push(mkConcealSpec({
				start: start,
				end: end,
				text: greekSymbolMap[value],
				class: "cm-concealed-underline",
			}));
		}
		else if (type === "boldsymbol") {
			specs.push(mkConcealSpec({
				start: start,
				end: end,
				text: greekSymbolMap[value],
				class: "cm-concealed-bold",
			}));
		}
	}

	return specs;
}

function concealText(eqn: string): ConcealSpec[] {

	const regexStr = "\\\\text{([A-Za-z0-9-.!?() ]+)}";
	const regex = new RegExp(regexStr, "g");

	const matches = [...eqn.matchAll(regex)];

	const specs: ConcealSpec[] = [];

	for (const match of matches) {
		const value = match[1];

		const start = match.index;
		const end = start + match[0].length;

		specs.push(mkConcealSpec({
			start: start,
			end: end,
			text: value,
			class: "cm-concealed-mathrm cm-variable-2",
		}));

	}

	return specs;
}

function concealOperators(eqn: string, symbols: string[]): ConcealSpec[] {

	const regexStr = "(\\\\(" + symbols.join("|") + "))([^a-zA-Z]|$)";
	const regex = new RegExp(regexStr, "g");

	const matches = [...eqn.matchAll(regex)];

	const specs: ConcealSpec[] = [];

	for (const match of matches) {
		const value = match[2];

		const start = match.index;
		const end = getEndIncludingLimits(eqn, start + match[1].length);

		specs.push(mkConcealSpec({
			start: start,
			end: end,
			text: value,
			class: "cm-concealed-mathrm cm-variable-2",
		}));
	}

	return specs;
}

function concealAtoZ(eqn: string, prefix: string, suffix: string, symbolMap: {[key: string]: string}, className?: string): ConcealSpec[] {

	const regexStr = prefix + "([A-Z]+)" + suffix;
	const symbolRegex = new RegExp(regexStr, "g");


	const matches = [...eqn.matchAll(symbolRegex)];

	const specs: ConcealSpec[] = [];

	for (const match of matches) {
		const symbol = match[1];
		const letters = Array.from(symbol);
		const replacement = letters.map(el => symbolMap[el]).join("");

		specs.push(mkConcealSpec({
			start: match.index,
			end: match.index + match[0].length,
			text: replacement,
			class: className,
		}));
	}

	return specs;
}

function concealBraKet(eqn: string): ConcealSpec[] {
	const langle = "〈";
	const rangle = "〉";
	const vert = "|";

	const specs: ConcealSpec[] = [];

	for (const match of eqn.matchAll(/\\(braket|bra|ket){/g)) {
		// index of the "}"
		const contentEnd = findMatchingBracket(eqn, match.index, "{", "}", false);
		if (contentEnd === -1) continue;

		const commandStart = match.index;
		// index of the "{"
		const contentStart = commandStart + match[0].length - 1;

		const type = match[1];
		const left = type === "ket" ? vert : langle;
		const right = type === "bra" ? vert : rangle;

		specs.push(mkConcealSpec(
			// Hide the command
			{ start: commandStart, end: contentStart, text: "" },
			// Replace the "{"
			{ start: contentStart, end: contentStart + 1, text: left, class: "cm-bracket" },
			// Replace the "}"
			{ start: contentEnd, end: contentEnd + 1, text: right, class: "cm-bracket" },
		));
	}

	return specs;
}

function concealSet(eqn: string): ConcealSpec[] {
	const specs: ConcealSpec[] = [];

	for (const match of eqn.matchAll(/\\set\{/g)) {
		const commandStart = match.index;
		// index of the "{"
		const contentStart = commandStart + match[0].length - 1;

		// index of the "}"
		const contentEnd = findMatchingBracket(eqn, commandStart, "{", "}", false);
		if (contentEnd === -1) continue;

		specs.push(mkConcealSpec(
			// Hide "\set"
			{ start: commandStart, end: contentStart, text: "" },
			// Replace the "{"
			{ start: contentStart, end: contentStart + 1, text: "{", class: "cm-bracket" },
			// Replace the "}"
			{ start: contentEnd, end: contentEnd + 1, text: "}", class: "cm-bracket" },
		));
	}

	return specs;
}

function concealFraction(eqn: string): ConcealSpec[] {
	const concealSpecs: ConcealSpec[] = [];

	for (const match of eqn.matchAll(/\n?\\(frac|dfrac|tfrac|gfrac){/g)) {
		// index of the closing bracket of the numerator
		const numeratorEnd = findMatchingBracket(eqn, match.index, "{", "}", false);
		if (numeratorEnd === -1) continue;

		// Expect there are no spaces between the closing bracket of the numerator
		// and the opening bracket of the denominator
		if (eqn.charAt(numeratorEnd + 1) !== "{") continue;

		// index of the closing bracket of the denominator
		const denominatorEnd = findMatchingBracket(eqn, numeratorEnd + 1, "{", "}", false);
		if (denominatorEnd === -1) continue;

		const commandStart = match.index + +(match[0][0] === "\n");
		// The home key needs some **visually** to grab onto, so if the \frac is at the start of a line,
		// it would go to \\frac| instead of |\\frac. Hence we replace \frac with a space in this case.
		const hideFrac = match[0][0] === "\n" ? " " : "";
		const numeratorStart = match.index + match[0].length - 1;
		const denominatorStart = numeratorEnd + 1;

		concealSpecs.push(mkConcealSpec(
			// Hide "\frac"
			{ start: commandStart, end: numeratorStart, text: hideFrac },
			// Replace brackets of the numerator
			{ start: numeratorStart, end: numeratorStart + 1, text: "(", class: "cm-bracket" },
			{ start: numeratorEnd, end: numeratorEnd + 1, text: ")", class: "cm-bracket"},
			// Add a slash
			{ start: numeratorEnd + 1, end: numeratorEnd + 1, text: "/", class: "cm-bracket" },
			// Replace brackets of the denominator
			{ start: denominatorStart, end: denominatorStart + 1, text: "(", class: "cm-bracket" },
			{ start: denominatorEnd, end: denominatorEnd + 1, text: ")", class: "cm-bracket" },
		));
	}

	return concealSpecs;
}

function concealOperatorname(eqn: string): ConcealSpec[] {
	const regexStr = "\\\\operatorname{([A-Za-z]+)}";
	const regex = new RegExp(regexStr, "g");
	const matches = [...eqn.matchAll(regex)];
	const specs: ConcealSpec[] = [];

	for (const match of matches) {
		const value = match[1];
		const start2 = match.index!;
		const end2 = start2 + match[0].length;

		specs.push(mkConcealSpec({
			start: start2,
			end: end2,
			text: value,
			class: "cm-concealed-mathrm cm-variable-2"
		}));
	}

	return specs;
}

export type ConcealCachedEquations = Record<string, ConcealSpec[]>;
export function conceal(
	view: EditorView,
	cached_equations: ConcealCachedEquations,
): { specs: ConcealSpec[]; cached_equations: ConcealCachedEquations } {
	const equations = getMathBoundsPlugin(view).getEquations(view.state);
	const new_equations: typeof cached_equations = {};

	for (const eqn of equations.values()) {
		if (eqn in cached_equations) {
			new_equations[eqn] = cached_equations[eqn];
			continue;
		}

		const localSpecs = [
			...concealSymbols(eqn, "\\^", "", map_super),
			...concealSymbols(eqn, "_", "", map_sub),
			...concealSymbols(eqn, "\\\\frac", "", fractions),
			...concealNotSymbols(eqn, ALL_SYMBOLS, not_remap),
			...concealSupSub(eqn, true, ALL_SYMBOLS),
			...concealSupSub(eqn, false, ALL_SYMBOLS),
			...concealModifier(eqn, "hat", "\u0302"),
			...concealModifier(eqn, "dot", "\u0307"),
			...concealModifier(eqn, "ddot", "\u0308"),
			...concealModifier(eqn, "overline", "\u0304"),
			...concealModifier(eqn, "bar", "\u0304"),
			...concealModifier(eqn, "tilde", "\u0303"),
			...concealModifier(eqn, "vec", "\u20D7"),
			...concealSymbols(eqn, "\\\\", "", brackets, "cm-bracket"),
			...concealAtoZ(eqn, "\\\\mathcal{", "}", mathscrcal),
			...concealModifiedGreekLetters(eqn, greek),
			...concealModified_A_to_Z_0_to_9(eqn, mathbb),
			...concealText(eqn),
			...concealBraKet(eqn),
			...concealSet(eqn),
			...concealFraction(eqn),
			...concealOperators(eqn, operators),
			...concealOperatorname(eqn),
		];
		new_equations[eqn] = localSpecs;
	}
	cached_equations = new_equations;

	// Make the 'start' and 'end' fields represent positions in the entire
	// document (not in a math expression)
	const specs: ConcealSpec[] = [];
	for (const [start, eqn] of equations.entries()) {
		for (const spec of new_equations[eqn]) {
			specs.push(
				spec.map((replace) => ({
					...replace,
					start: replace.start + start,
					end: replace.end + start,
				})),
			);
		}
	}

	return { specs, cached_equations };
}
